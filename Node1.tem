// FILE: node1.tem
// IMPLEMENTS: The functions of the node class and the
// linked list toolkit (see node1.h for documentation).
// INVARIANT for the node class:
//   The data of a node is stored in data_field, and the link in link_field.

#include <cassert>    // Provides assert
#include <cstdlib>    // Provides NULL and size_t

template<typename T>
    size_t list_length(const node<T>* head_ptr)
    // Library facilities used: cstdlib
    {
	const node<T> *cursor;
	size_t answer;

	answer = 0;
	for (cursor = head_ptr; cursor != NULL; cursor = cursor->link( ))
	    ++answer;
	
	return answer;
    }

template<typename T>    
    void list_head_insert(node<T>*& head_ptr, const T& entry)
    {
	head_ptr = new node<T>(entry, head_ptr);
    }

template<typename T>
    void list_insert(node<T>* previous_ptr, const T& entry) 
    {
	node<T> *insert_ptr;
    
	insert_ptr = new node<T>(entry, previous_ptr->link( ));
	previous_ptr->set_link(insert_ptr);
    }

template<typename T>
    node<T>* list_search(node<T>* head_ptr, T& target) 
    // Library facilities used: cstdlib
    {
	node<T> *cursor;
   
	for (cursor = head_ptr; cursor != NULL; cursor = cursor->link( ))
	    if (target == cursor->data( ))
		return cursor;
	return NULL;
    }

template<typename T>
    const node<T>* list_search(const node<T>* head_ptr, T& target) 
    // Library facilities used: cstdlib
    {
	const node<T> *cursor;
   
	for (cursor = head_ptr; cursor != NULL; cursor = cursor->link( ))
	    if (target == cursor->data( ))
		return cursor;
	return NULL;
    }

template<typename T>
    node<T>* list_locate(node<T>* head_ptr, size_t position) 
    // Library facilities used: cassert, cstdlib
    {
	node<T> *cursor;
	size_t i;
    
	assert (0 < position);
	cursor = head_ptr;
	for (i = 1; (i < position) && (cursor != NULL); i++)
	    cursor = cursor->link( );
	return cursor;
    }

template<typename T>
    const node<T>* list_locate(const node<T>* head_ptr, size_t position) 
    // Library facilities used: cassert, cstdlib
    {
	const node<T> *cursor;
	size_t i;
    
	assert (0 < position);
	cursor = head_ptr;
	for (i = 1; (i < position) && (cursor != NULL); i++)
	    cursor = cursor->link( );
	return cursor;
    }

template<typename T>
    void list_head_remove(node<T>*& head_ptr)
    {
	node<T> *remove_ptr;

	remove_ptr = head_ptr;
	head_ptr = head_ptr->link( );
	delete remove_ptr;
    }

template<typename T>
    void list_remove(node<T>* previous_ptr)
    {
	node *remove_ptr;

	remove_ptr = previous_ptr->link( );
	previous_ptr->set_link( remove_ptr->link( ) );
	delete remove_ptr;
    }

template<typename T>
    void list_clear(node<T>*& head_ptr)
    // Library facilities used: cstdlib
    {
	while (head_ptr != NULL)
	    list_head_remove(head_ptr);
    }

template<typename T>
    void list_copy(const node<T>* source_ptr, node<T>*& head_ptr, node<T>*& tail_ptr) 
    // Library facilities used: cstdlib
    {
		head_ptr = NULL;
		tail_ptr = NULL;

		// Handle the case of the empty list.
		if (source_ptr == NULL)
		    return;
    
		// Make the head node for the newly created list, and put data in it.
		list_head_insert(head_ptr, source_ptr->data( ));
		tail_ptr = head_ptr;
    
		// Copy the rest of the nodes one at a time, adding at the tail of new list.
		source_ptr = source_ptr->link( ); 
		while (source_ptr != NULL)
		{
		    list_insert(tail_ptr, source_ptr->data( ));
		    tail_ptr = tail_ptr->link( );
		    source_ptr = source_ptr->link( );
		}
	}